### **변수란?**

- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
- 값을 저장하고 참고하는 메커니즘 (값의 위치를 가리키는 상징적인 이름)
  - 컴파일어 또는 인터프리터에 의해 컴파일되어 값이 저장된 메모리 공간의 주소로 치환되어 실행

\*\* 변수는 하나의 값을 저장하기 위한 메커니즘으로 여러 개의 값을 저장하려면 여러 개의 변수를 사용해야 함.

\*\* 배열이나 객체같은 자료구조를 사용하면 관련 있는 여러 개의 값을 그룹화해서 하나의 값처럼 사용 가능

```jsx
// 변수 : 하나의 값 지정 => var 변수명 = 변수값;
var userId = 1;
var userName = "Lee";

// 객체나 배열 같은 자료구조로 여러 개의 값 그룹화 하여 하나의 값 처럼 사용
var user = { id: 1, name: "Lee" };

var users = [
  { id: 1, name: "Lee" },
  { id: 2, name: "Kim" },
];
```

### **식별자란?**

- 어떤 값을 구별해서 식별할 수 있는 고유한 이름 (변수명 등)
- 값이 아닌 메모리 주소를 기억하고 있음
  ⇒ 값은 메모리 공간에 저장되어 있고, 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별해 낼 수 있어야 함.
  즉, 어떤 값이 저장되어있는 메모리 주소를 기억(저장)해야 함.
- 메모리 주소에 붙인 이름으로 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자
  ⇒ ex. 변수명, 함수명, 클래스명 등

** 식별자는 네이밍 규칙을 준수해야하며, **선언(declaration)\*\*에 의해 js 엔진에 식별자의 존재를 알림

** 모든 식별자는 사용하려면 반드시 **선언\*\* 필요

선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러) 발생

**_참조에러?식별자를 통해 값을 참조하려 했지만, js 엔진이 등록된 식별자를 찾을 수 없을 경우_**

### 변수 선언이란?

- 값을 저장하기 위한 메모리 공간을 확보하고, 변수명과 확보된 메모리 주소를 연결해서 값을 저장할 수 있게 준비
  ⇒ 확보가 해제되기 전까지 누구도 확보된 메모리 공간을 사용할 수 없도록 보호됨
- 변수를 사용하려면 반드시 선언이 필요하며 **var, let, const 키워드** 사용

> 🏗️**var, let , const 비교하기**
>
> - 보류

**변수 선언의 단계**

선언 단계 : 변수 이름을 등록해서 js 엔진에 존재를 알림

초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당

[ var 키워드 ]

- 뒤에 오는 변수 이름으로 새로운 변수를 선언할 것을 지시하는 키워드
  - 변수 선언 후 값을 할당하지 않아서 확보된 메모리 공간이 비어있을 것으로 생각할 수 있으나, js 엔진에 의해 암묵적으로 undefined라는 값이 할당되어 초기화 ⇒ 원시 타입의 값(primitive value)

\*\* 선언과 초기화를 동시에 진행

---

일반적인 초기화 : 변수가 선언된 이후 최초로 값을 할당하는 것

만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 다른 애플리케이션이 사용했던 값이 남아있을 수 있음( = garbage value)

따라서 메모리 공간을 확보한 다음 값을 할당하지 않은 상태에서 변수 값을 참조하면 쓰레기 값이 나올 수 있지만, var 키워드는 암묵적으로 초기화를 수행하여 이러한 위험으로부터 안전

### 변수 선언의 실행 시점과 변수 호이스팅

- js코드는 인터프리터에 의해 한 줄씩 순차적으로 실행됨으로 변수 선언문보다 변수를 참조하는 코드가 먼저 있을 때 참조 에러가 발생할 것으로 보이지만 undefined가 출력됨
  ⇒ 변수 선언이 런타임(소스코드가 한 줄씩 순차적으로 실행되는 시점)이 아니라 그 이전 단계에서 실행되기 때문
  ⇒ **소스코드의 평가 과정을 먼저 거치고, 평가 과정이 끝나면 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄 씩 순차적으로 실행**

\*\* js 엔진은 변수 선언을 포함한 모든값

⇒ 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행. 따라서 어디서든지 변수 참조 가능.

- 변수 호이스팅 : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 js 고유의 특징

\*\* var, let, const, function, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅 됨 → why? 모든 선언문은 런타임 이전 단계에서 실행되기 때문

### 값의 할당

- 변수 선언은 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행
- 변수 선언과 값의 할당을 하나의 문으로 단축 표현 가능

### 값의 재할당

- 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것
- 재할당은 현재 변수에 새로운 값을 저장하는 것이지만, var 키워드로 선언한 변수는 선언과 동시에 undefined로 초기화 되어서 처음 값을 할당하는 것도 재할당
- 재할당되어 불필요해진 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제되지만 언제 해제될지는 예측할 수 없음

\*\* 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아닌 상수

### 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, 언더 스코어(\_), 달러($) 기호를 포함할 수 있다
- 식별자는 특수문자를 제외한 문자, 언더스코어(\_), 달러($) 기호로 시작해야 한다. 숫자로 시작하는 것은 허용 X
- 예약어는 식별자로 사용 불가

---

**[ 예약어 ]** \*식별자로 사용 가능하나 strict mode에서는 사용 불가

| await       | break    | case         | catch   | class     | const      |
| ----------- | -------- | ------------ | ------- | --------- | ---------- |
| continue    | debugger | default      | delete  | do        | else       |
| enum        | export   | extends      | false   | finally   | for        |
| function    | if       | \*implements | import  | in        | instanceof |
| \*interface | \*let    | new          | null    | \*package | \*private  |
| \*protected | \*public | return       | super   | \*static  | switch     |
| this        | throw    | true         | try     | typeof    | var        |
| void        | while    | with         | \*yield |           |            |

---

- 변수명도 식별자이므로 네이밍 규칙을 따름
- 변수는 쉼표(,)로 구분해 하나의 문에서 여러 개를 한 번에 선언할 수 있음
- 네이밍 컨벤션(naming convention)은 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 구분하기 위해 규정한 명명 규칙
  ⇒ 자주 사용되는 4가지 유형

      // 카멜 케이스(camelCase)
      var firstName;

      // 스네이크 케이스(snake_case)
      var first_name;

      // 파스칼 케이스(PascalCase)
      var FirstName;

      // 헝가리언 케이스(typeHungarianCase)
      var srtFirstName; // type + identifier
      var $elem = document.getElementById('myId'); // DOM 노드
      var observable$ = fromEvent(document, 'click'); //RxJS 옵저버블
      ```

      일관성을 유지한다면 어떤 네이밍 컨벤션을 사용해도 좋지만, js에서는 일반적으로 변수나 함수명에는 **카멜 케이스**를 사용하고, 생성자 함수, 클래스의 이름에는 **파스칼 케이스**를 사용

      ECMAScript 사양에 정의되어 있는 객체와 함수들도 카멜 케이스와 파스칼 케이스 사용
